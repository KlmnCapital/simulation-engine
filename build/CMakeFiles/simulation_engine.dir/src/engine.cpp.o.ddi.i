# 0 "/home/nemeleks/kelemen_capital/dev/simulation_engine/src/engine.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "/home/nemeleks/kelemen_capital/dev/simulation_engine/src/engine.cpp"

module;
# 1 "/usr/include/c++/15.2.1/cassert" 1 3
# 45 "/usr/include/c++/15.2.1/cassert" 3
# 1 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 37 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wvariadic-macros"

#pragma GCC diagnostic ignored "-Wc++11-extensions"
#pragma GCC diagnostic ignored "-Wc++23-extensions"
# 336 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;


#pragma GCC visibility push(default)


  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__,__cold__));
    terminate();
  }
#pragma GCC visibility pop
}
# 369 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 573 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)




  __attribute__((__always_inline__))
  constexpr inline bool
  __is_constant_evaluated() noexcept
  {


    if consteval { return true; } else { return false; }






  }
#pragma GCC visibility pop
}
# 617 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)

  extern "C++" __attribute__ ((__noreturn__)) __attribute__((__cold__))
  void
  __glibcxx_assert_fail
    (const char* __file, int __line, const char* __function,
     const char* __condition)
  noexcept;
#pragma GCC visibility pop
}
# 648 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  __attribute__((__always_inline__,__visibility__("default")))
  inline void
  __glibcxx_assert_fail()
  { }
}
# 727 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 39 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 415 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/bits/timesize.h" 1 3 4
# 19 "/usr/include/bits/timesize.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 20 "/usr/include/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 416 "/usr/include/features.h" 2 3 4
# 524 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 730 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 731 "/usr/include/sys/cdefs.h" 2 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 732 "/usr/include/sys/cdefs.h" 2 3 4
# 525 "/usr/include/features.h" 2 3 4
# 548 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 549 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 2 3
# 728 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 731 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 887 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace __gnu_cxx
{
  typedef __decltype(0.0bf16) __bfloat16_t;
}
# 949 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/15.2.1/pstl/pstl_config.h" 1 3
# 950 "/usr/include/c++/15.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3



#pragma GCC diagnostic pop
# 46 "/usr/include/c++/15.2.1/cassert" 2 3
# 1 "/usr/include/assert.h" 1 3 4
# 47 "/usr/include/c++/15.2.1/cassert" 2 3
# 4 "/home/nemeleks/kelemen_capital/dev/simulation_engine/src/engine.cpp" 2


# 5 "/home/nemeleks/kelemen_capital/dev/simulation_engine/src/engine.cpp"
module simulation_engine;

import std;

namespace sim {

    template <std::size_t depth>
    Engine<depth>::Engine(std::unique_ptr<IMarketData<depth>> marketData, RunParams params)
        : marketData_(std::move(marketData)), params_(params), stats_(params) {
        portfolio_.cash = params.startingCash;
        portfolio_.settledFunds = params.startingCash;
        portfolio_.interestRate = params.interestRate;


        if (params.useRandomness) {
            if (params.randomSeed == 0) {

                std::random_device rd;
                randomNumberGenerator_.seed(rd());
            } else {

                randomNumberGenerator_.seed(params.randomSeed);
            }
        }


        fillRateDistribution_ = std::normal_distribution<float>(params.fillRate, params.fillRateStdDev);
        partialFillProbabilityDistribution_ =
            std::uniform_int_distribution<int>(0, 99);
    }

    template <std::size_t depth>
    Result Engine<depth>::run(IStrategy<depth>& strategy, VerbosityLevel verbosity, std::ostream& out) {
        strategy_ = &strategy;
        strategy.setEngine(this);
        currentVerbosity_ = verbosity;


        sendLatencyNs_ = params_.sendLatencyNanoseconds;
        receiveLatencyNs_ = params_.receiveLatencyNanoseconds;
        totalLatencyNs_ = sendLatencyNs_ + receiveLatencyNs_;

        Result result = simulate(strategy);


        stats_.outputSummary(out, verbosity);

        return result;
    }

    template <std::size_t depth>
    const Portfolio& Engine<depth>::portfolio() const {
        return portfolio_;
    }

    template <std::size_t depth>
    const Quote<depth>& Engine<depth>::marketData(SymbolId symbol) const {
        return currentQuote_;
    }

    template <std::size_t depth>
    bool Engine<depth>::sufficientEquityForOrder(const NewOrder& order) {
        
# 67 "/home/nemeleks/kelemen_capital/dev/simulation_engine/src/engine.cpp" 3 4
       (static_cast<void> (0))
# 67 "/home/nemeleks/kelemen_capital/dev/simulation_engine/src/engine.cpp"
                                                                                          ;

        auto currentQuote = marketData_->currentQuote();
        Ticks bestBid = currentQuote.bestBid();
        Ticks bestAsk = currentQuote.bestAsk();

        return portfolio_.sufficientEquityForOrder(order, bestBid, bestAsk, params_.leverageFactor);
    }

    template <std::size_t depth>
    OrderId Engine<depth>::placeOrder(SymbolId symbol,
        OrderInstruction instruction,
        OrderType orderType,
        Quantity quantity,
        TimeInForce timeInForce,
        Ticks price) {
        NewOrder order;
        order.id = ++nextOrderId_;
        order.symbol = symbol;
        order.instruction = instruction;
        order.orderType = orderType;
        order.quantity = quantity;
        order.timeInForce = timeInForce;
        order.price = price;

        if (!portfolio_.sufficientEquityForOrder(
                order, currentQuote_.bestBid(), currentQuote_.bestAsk(), params_.leverageFactor)) {
            std::cout << "Conditions not met to place order!";
            return OrderId{0};
        }

        TimeStamp sendTime = currentQuote_.timestamp;
        TimeStamp earliestExecution = TimeStamp(sendTime.value() + totalLatencyNs_);

        PendingOrder pendingOrder;
        pendingOrder.order = order;
        pendingOrder.sendTime = sendTime;
        pendingOrder.earliestExecution = earliestExecution;

        pendingOrders_.push_back(pendingOrder);

        stats_.recordOrderPlaced(order, sendTime);

        return order.id;
    }

    template <std::size_t depth>
    bool Engine<depth>::cancel(OrderId orderId) {

        auto it = std::find_if(pendingOrders_.begin(), pendingOrders_.end(),
            [orderId](const PendingOrder& po) { return po.order.id == orderId; });

        if (it != pendingOrders_.end()) {




            TimeStamp sendTime = currentQuote_.timestamp;
            TimeStamp earliestExecution = TimeStamp(sendTime.value() + totalLatencyNs_);

            CancelOrder cancelOrder;
            cancelOrder.orderId = orderId;
            cancelOrder.sendTime = sendTime;
            cancelOrder.earliestExecution = earliestExecution;

            pendingCancels_.push_back(cancelOrder);
            return true;
        }
        return false;
    }

    template <std::size_t depth>
    bool Engine<depth>::replace(OrderId orderId, Quantity newQuantity, Ticks newPrice) {

        auto it = std::find_if(pendingOrders_.begin(), pendingOrders_.end(),
            [orderId](const PendingOrder& po) { return po.order.id == orderId; });

        if (it != pendingOrders_.end()) {

            TimeStamp sendTime = currentQuote_.timestamp;
            TimeStamp earliestExecution = TimeStamp(sendTime.value() + totalLatencyNs_);

            ReplaceOrder replaceOrder;
            replaceOrder.orderId = orderId;
            replaceOrder.newQuantity = newQuantity;
            replaceOrder.newPrice = newPrice;
            replaceOrder.sendTime = sendTime;
            replaceOrder.earliestExecution = earliestExecution;

            pendingReplaces_.push_back(replaceOrder);
            return true;
        }
        return false;
    }

    template <std::size_t depth>
    Result Engine<depth>::simulate(IStrategy<depth>& strategy) {
        strategy_ = &strategy;


        while (marketData_->nextQuote()) {
            currentQuote_ = marketData_->currentQuote();
            ++quotesProcessed_;


            strategy.onMarketData(currentQuote_);


            checkMarginRequirement();



            processPendingOrders();



            processPendingNotifications(strategy);


            processSettlements();
        }

        strategy.onEnd();


        stats_.updateInterestOwed(portfolio_.interestOwed);

        return Result{std::move(fills_), portfolio_, quotesProcessed_};
    }

    template <std::size_t depth>
    typename Engine<depth>::ExecutionResult Engine<depth>::tryExecute(const NewOrder& newOrder,
        TimeStamp sendTs,
        const Quote<depth>& quote) {
        ExecutionResult result;
        result.fills.clear();
        result.remainingOrder = newOrder;
        result.isComplete = false;

        if (newOrder.orderType == OrderType::Market) {

            int actualFillRate;
            int fillDecision;

            if (params_.useRandomness) {
                actualFillRate =
                    std::clamp(static_cast<int>(fillRateDistribution_(randomNumberGenerator_)), 0, 100);
                fillDecision = partialFillProbabilityDistribution_(randomNumberGenerator_);
            } else {
                actualFillRate = params_.fillRate;
                fillDecision = 0;
            }

            if (fillDecision < actualFillRate) {

                bool isPartialFill;
                if (params_.useRandomness) {
                    isPartialFill = (partialFillProbabilityDistribution_(randomNumberGenerator_) <
                        params_.partialFillProbability);
                } else {
                    isPartialFill = (params_.partialFillProbability > 0);
                }
                Quantity fillQuantity =
                    isPartialFill ? Quantity{newOrder.quantity.value() / 2} : newOrder.quantity;

                Ticks executionPrice;
                if (newOrder.instruction == OrderInstruction::Buy) {
                    executionPrice = quote.bestAsk();
                } else {
                    executionPrice = quote.bestBid();
                }

                Fill fill;
                fill.id = newOrder.id;
                fill.symbol = newOrder.symbol;
                fill.quantity = fillQuantity;
                fill.price = executionPrice;
                fill.timestamp = quote.timestamp;
                fill.instruction = newOrder.instruction;
                fill.orderType = newOrder.orderType;
                fill.timeInForce = newOrder.timeInForce;
                fill.originalPrice = newOrder.price;

                result.fills.push_back(fill);
                result.isComplete = !isPartialFill;

                if (isPartialFill) {
                    result.remainingOrder = newOrder;
                    result.remainingOrder.quantity =
                        Quantity{newOrder.quantity.value() - fillQuantity.value()};
                }


                portfolio_.updatePortfolio(fill);


                stats_.recordFillReceived(fill);


                Ticks currentEquity =
                    portfolio_.currentValue(currentQuote_.bestBid(), currentQuote_.bestAsk());
                stats_.updateCurrentEquity(currentEquity);


                stats_.updateStatsOnFill(
                    portfolio_.cash, portfolio_.longQuantity, portfolio_.costBasis, currentVerbosity_);
                stats_.updateInterestOwed(portfolio_.interestOwed);


                TimeStamp notificationTime = TimeStamp{fill.timestamp.value() + receiveLatencyNs_};
                notifyFill(fill, notificationTime);
            }


        } else if (newOrder.orderType == OrderType::Limit) {

            bool priceFavorable = false;
            Ticks executionPrice = newOrder.price;

            if (newOrder.instruction == OrderInstruction::Buy) {

                priceFavorable = (quote.bestAsk() <= newOrder.price);
                executionPrice = std::min(quote.bestAsk(), newOrder.price);
            } else {

                priceFavorable = (quote.bestBid() >= newOrder.price);
                executionPrice = std::max(quote.bestBid(), newOrder.price);
            }

            if (priceFavorable) {

                int actualFillRate;
                int fillDecision;

                if (params_.useRandomness) {
                    actualFillRate = std::clamp(
                        static_cast<int>(fillRateDistribution_(randomNumberGenerator_)), 0, 100);
                    fillDecision = partialFillProbabilityDistribution_(randomNumberGenerator_);
                } else {
                    actualFillRate = params_.fillRate;
                    fillDecision = 0;
                }

                if (fillDecision < actualFillRate) {

                    bool isPartialFill;
                    if (params_.useRandomness) {
                        isPartialFill = (partialFillProbabilityDistribution_(randomNumberGenerator_) <
                            params_.partialFillProbability);
                    } else {
                        isPartialFill = (params_.partialFillProbability > 0);
                    }
                    Quantity fillQuantity =
                        isPartialFill ? Quantity{newOrder.quantity.value() / 2} : newOrder.quantity;

                    Fill fill;
                    fill.id = newOrder.id;
                    fill.symbol = newOrder.symbol;
                    fill.quantity = fillQuantity;
                    fill.price = executionPrice;
                    fill.timestamp = quote.timestamp;
                    fill.instruction = newOrder.instruction;
                    fill.orderType = newOrder.orderType;
                    fill.timeInForce = newOrder.timeInForce;
                    fill.originalPrice = newOrder.price;

                    result.fills.push_back(fill);
                    result.isComplete = !isPartialFill;

                    if (isPartialFill) {
                        result.remainingOrder = newOrder;
                        result.remainingOrder.quantity =
                            Quantity{newOrder.quantity.value() - fillQuantity.value()};
                    }


                    portfolio_.updatePortfolio(fill);


                    stats_.recordFillReceived(fill);


                    Ticks currentEquity =
                        portfolio_.currentValue(currentQuote_.bestBid(), currentQuote_.bestAsk());
                    stats_.updateCurrentEquity(currentEquity);


                    stats_.updateStatsOnFill(portfolio_.cash, portfolio_.longQuantity,
                        portfolio_.costBasis, currentVerbosity_);
                    stats_.updateInterestOwed(portfolio_.interestOwed);


                    TimeStamp notificationTime = TimeStamp{fill.timestamp.value() + receiveLatencyNs_};
                    notifyFill(fill, notificationTime);
                }

            }

        }

        return result;
    }

    template <std::size_t depth>
    void Engine<depth>::notifyFill(const Fill& fill, TimeStamp earliestNotificationTime) {

        fills_.push_back(fill);


        pendingNotifications_.push_back({fill, earliestNotificationTime, false});
    }

    template <std::size_t depth>
    void Engine<depth>::processPendingNotifications(IStrategy<depth>& strategy) {
        auto it = pendingNotifications_.begin();
        while (it != pendingNotifications_.end()) {
            if (!it->delivered && currentQuote_.timestamp >= it->earliestNotifyTime) {

                strategy.onFill(it->fill);
                it->delivered = true;
                ++it;
            } else {
                ++it;
            }
        }


        pendingNotifications_.erase(
            std::remove_if(pendingNotifications_.begin(), pendingNotifications_.end(),
                [](const PendingNotification& notif) { return notif.delivered; }),
            pendingNotifications_.end());
    }

    template <std::size_t depth>
    void Engine<depth>::processPendingOrders() {

        auto cancelIt = pendingCancels_.begin();
        while (cancelIt != pendingCancels_.end()) {
            if (currentQuote_.timestamp >= cancelIt->earliestExecution) {

                auto orderIt = std::find_if(pendingOrders_.begin(), pendingOrders_.end(),
                    [cancelIt](const PendingOrder& po) { return po.order.id == cancelIt->orderId; });

                if (orderIt != pendingOrders_.end()) {
                    pendingOrders_.erase(orderIt);
                }


                cancelIt = pendingCancels_.erase(cancelIt);
            } else {
                ++cancelIt;
            }
        }


        auto replaceIt = pendingReplaces_.begin();
        while (replaceIt != pendingReplaces_.end()) {
            if (currentQuote_.timestamp >= replaceIt->earliestExecution) {

                auto orderIt = std::find_if(pendingOrders_.begin(), pendingOrders_.end(),
                    [replaceIt](const PendingOrder& po) { return po.order.id == replaceIt->orderId; });

                if (orderIt != pendingOrders_.end()) {
                    orderIt->order.quantity = replaceIt->newQuantity;
                    orderIt->order.price = replaceIt->newPrice;
                }


                replaceIt = pendingReplaces_.erase(replaceIt);
            } else {
                ++replaceIt;
            }
        }


        auto it = pendingOrders_.begin();
        while (it != pendingOrders_.end()) {
            if (currentQuote_.timestamp >= it->earliestExecution) {
                ExecutionResult result = tryExecute(it->order, it->sendTime, currentQuote_);

                if (result.isComplete) {

                    it = pendingOrders_.erase(it);
                } else {

                    it->order = result.remainingOrder;
                    ++it;
                }
            } else {
                ++it;
            }
        }
    }

    template <std::size_t depth>
    Ticks Engine<depth>::currentPortfolioValue() const {
        return portfolio_.currentValue(currentQuote_.bestBid(), currentQuote_.bestAsk());
    }

    template <std::size_t depth>
    void Engine<depth>::processSettlements() {

        if (isTimeForSettlement(currentQuote_.timestamp)) {

            portfolio_.processSettlements(currentQuote_.timestamp);


            portfolio_.calculateDailyInterest(currentQuote_.timestamp);

            lastSettlementDate_ = currentQuote_.timestamp;
        }
    }

    template <std::size_t depth>
    bool Engine<depth>::isTimeForSettlement(TimeStamp currentTime) const {

        constexpr std::uint64_t nanosecondsPerDay = 24ULL * 60 * 60 * 1000000000ULL;
        constexpr std::uint64_t nanosecondsPerHour = 60ULL * 60 * 1000000000ULL;

        std::uint64_t currentDay = currentTime.value() / nanosecondsPerDay;
        std::uint64_t lastSettlementDay = lastSettlementDate_.value() / nanosecondsPerDay;


        if (currentDay > lastSettlementDay) {
            std::uint64_t timeInDay = currentTime.value() % nanosecondsPerDay;
            std::uint64_t nineAM = 9ULL * nanosecondsPerHour;

            return timeInDay >= nineAM;
        }

        return false;
    }

    template <std::size_t depth>
    void Engine<depth>::checkMarginRequirement() {
        Ticks bestBid = currentQuote_.bestBid();
        Ticks bestAsk = currentQuote_.bestAsk();

        Ticks currentEquity = portfolio_.equity(bestBid, bestAsk);
        Ticks maintenanceReq =
            portfolio_.maintenanceRequirement(bestBid);


        if (currentEquity < maintenanceReq) {
            executeMarginCall();
        }
    }

    template <std::size_t depth>
    void Engine<depth>::executeMarginCall() {
        Ticks bestBid = currentQuote_.bestBid();
        Ticks bestAsk = currentQuote_.bestAsk();


        while (true) {
            Ticks currentEquity = portfolio_.equity(bestBid, bestAsk);
            Ticks maintenanceReq = portfolio_.maintenanceRequirement(bestBid);


            if (currentEquity >= maintenanceReq) {
                break;
            }


            bool liquidated = false;


            if (portfolio_.longQuantity > Quantity{0}) {
                Quantity liquidateQty =
                    std::min(portfolio_.longQuantity, Quantity{100});

                Fill marginCallFill;
                marginCallFill.id = OrderId{0};
                marginCallFill.symbol = SymbolId{1};
                marginCallFill.quantity = liquidateQty;
                marginCallFill.price = bestBid;
                marginCallFill.timestamp = currentQuote_.timestamp;
                marginCallFill.instruction = OrderInstruction::Sell;
                marginCallFill.orderType = OrderType::Market;
                marginCallFill.timeInForce = TimeInForce::Day;
                marginCallFill.originalPrice = bestBid;


                portfolio_.updatePortfolio(marginCallFill);


                stats_.recordFillReceived(marginCallFill);
                TimeStamp notificationTime =
                    TimeStamp{marginCallFill.timestamp.value() + receiveLatencyNs_};
                notifyFill(marginCallFill, notificationTime);

                liquidated = true;
            }

            else if (portfolio_.shortQuantity > Quantity{0}) {
                Quantity liquidateQty =
                    std::min(portfolio_.shortQuantity, Quantity{100});

                Fill marginCallFill;
                marginCallFill.id = OrderId{0};
                marginCallFill.symbol = SymbolId{1};
                marginCallFill.quantity = liquidateQty;
                marginCallFill.price = bestAsk;
                marginCallFill.timestamp = currentQuote_.timestamp;
                marginCallFill.instruction = OrderInstruction::Buy;
                marginCallFill.orderType = OrderType::Market;
                marginCallFill.timeInForce = TimeInForce::Day;
                marginCallFill.originalPrice = bestAsk;


                portfolio_.updatePortfolio(marginCallFill);


                stats_.recordFillReceived(marginCallFill);
                TimeStamp notificationTime =
                    TimeStamp{marginCallFill.timestamp.value() + receiveLatencyNs_};
                notifyFill(marginCallFill, notificationTime);

                liquidated = true;
            }


            if (!liquidated) {
                break;
            }
        }
    }


    template class Engine<1>;
    template class Engine<5>;
    template class Engine<10>;

}
